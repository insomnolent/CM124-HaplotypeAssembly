import os
import sys
from collections import defaultdict

os.chdir('/Users/christinesun/GitHub/CM124-HaplotypeAssembly/Final_2')
# length is how long each haplotype is
# lines is how many read fragments there are
length = lines = 0


def read_input(input):
    data = open(input, 'r')
    matrix = []
    for line in data:
        # to account for the \n in each line
        matrix.append(line.rstrip())
    data.close()
    return matrix


# to remove repetitive read fragments
def removedupe(reads):
    nodupe = []
    for i in reads:
        if i not in nodupe:
            nodupe.append(i)
    return nodupe


# removes dashes before and after each string in the subset
def removeDash(set):
    newSet = [i for i in set if i != '-']
    return newSet


# return largest read in that subset
# for data sets where read lengths aren't all the same
def largest(set):
    large = ''
    for line in set:
        if len(line) >= len(large):
            large = line
    return large


# take subset of read_matrix of all fragments that start at that index
# returns subset with no dashes in the lines
def takeSubset(matrix, index):
    result = []
    for line in matrix:
        if index == 0:
            if line[index] != '-':
                result.append(line)
        else:
            if line[index] != '-' and line[index-1] == '-':
                result.append(line)
        if line[index] == '-' and len(result) != 0:
            # for now don't remove dashes since you want to create new matrix
            # res = removeDash(result)
            return result
    # res = removeDash(result)
    return result


# filter out reads that don't fit into haplotype
def filter(matrix, ref):
    temp = []
    for line in matrix:
        for i in range(0, len(line)):
            if line[i] != ref[i]:
                temp.append(line)
                break
    return temp


# write function that compares overlap of read to hap1 or hap2
# returns true if it overlaps, false if it doesn't
def compareReads(read, hap, index):
    result = True
    for j in range(index, len(hap)):
        # if finish iterating through read
        if j >= len(read) or read[j] == '-':
            break
            # if part of read disagrees with hap
        if read[j] != hap[j] and read[j] != '-':
            result = False
            break
    return result


# finds reads from subset that are similar (only 1 error) to read
def findSimilar(subset):
    # check each col of each line of subset and see how many cols match
    str = ""
    freq = []
    for i in range(0, len(subset)):
        str += subset[i]
        str += " "
    return freq


def gettopreads(subset):
    return top2(get_frequency(subset))


def get_frequency(subset):
    freq = defaultdict(int)
    for c in subset:
        freq[c] += 1
    return freq


def top2(frequency):
    array = [(k,v) for k,v in frequency.items()]
    sorted_array = sorted(array, key=lambda x: -x[1])
    if len(sorted_array) == 1:
        return [k for k, v in sorted_array[0:1]]
    else:
        return [k for k, v in sorted_array[0:2]]


def checkInverse(read1, read2):
    track = 0
    check = True
    for c in read1:
        if c == "1":
            if read2[track] != "0":
                check = False
                break
            track += 1
        elif c == "0":
            if read2[track] != "1":
                check = False
                break
            track += 1
    return check

# for reversing a string
# sum([abs(map(int, '10001')[i] - map(int, '0110')[i]) for i in range(len('1001'))])

# creates a new matrix with no sequencing errors
# looks at frequency of read fragments that appear in the matrix with errors
def newFiltered(reads, length):
    new = []
    for i in range(0, length):
        readset1 = takeSubset(reads, i)
        topreads = gettopreads(readset1)
        if len(topreads) == 1:
            new.append(topreads[0])
        elif len(topreads) > 1:
            read1 = removeDash(topreads[0])
            read2 = removeDash(topreads[1])

            if checkInverse(read1, read2):
                new.append(topreads[0])
                new.append(topreads[1])
    return new


# assuming part of read1 overlaps with hap, returns part of read1 that's different from hap
def findDiff(read, hap):
    result = ''
    count = 0
    start = findStart(read)
    for j in range(start, len(hap)):
        if read[j] == hap[j]:
            count += 1
    noDashes = removeDash(read)
    for k in range(start + count, len(noDashes)+start):
        result += read[k]
    # print result
    return result


# finds index where read fragment starts
def findStart(read):
    result = 0
    while read[result] == '-':
        result += 1
    return result


# test if 2nd read is completely overlapped by 1st read
def overlap(first, second):
    result = True
    for i in range(0, len(first)):
        if i < len(second) and first[i] != second[i]:
            result = False
    return result


# returns inverse of a read
def inverse(read):
    inv = ""
    for c in read:
        if c == "1":
            inv += "0"
        else:
            inv += "1"
    return inv


def percentOverlap(hap1, hap2):
    percent = 0
    track = 0
    for c in hap1:
        if c == hap2[track]:
            percent += 1
        track += 1
    return float(percent) / float(len(hap1)) * 100

# read in matrix
read_matrix = read_input('./medium/test/input/reads_high_error.txt')
# read_matrix = read_input('./medium_low_error_2_chromosomes_training_reads.txt')

# set size of read_matrix to new size
lines = len(read_matrix)
# check how long the haplotype should be later
length = len(read_matrix[0])

# make new matrix with longest reads from each subset
new_matrix = newFiltered(read_matrix, length)

# get rid of empty lines in new_matrix
new_matrix = [i for i in new_matrix if i != '']

hap1 = removeDash(new_matrix[0])
# if only one read for the first index of new matrix
if new_matrix[1][0] == '-':
    hap2 = inverse(hap1)
else:
    hap2 = removeDash(new_matrix[1])


# list comprehensions
# somelist[:] = [x for x in somelist if not determine(x)]
for i in range(2, len(new_matrix)):
    read1 = new_matrix[i]
    # print read1
    ind = findStart(read1)
    compare1 = compareReads(read1, hap1, ind)
    compare2 = compareReads(read1, hap2, ind)

    if compare1:
        hap1 += findDiff(read1, hap1)
        # print 'hap1 ', hap1
    elif compare2:
        hap2 += findDiff(read1, hap2)
        # print 'hap2 ', hap2

# for testing purposes
for i in range(0, len(hap1)):
    sys.stdout.write(hap1[i])

print "\n"
for i in range(0, len(hap2)):
    sys.stdout.write(hap2[i])

print "\n"
# Final_2, low error
answer1 = "0101000111001010110011110111100001111011010101110001011101100000001111000000110111110000010010101000000111010011110010110010010100100000011010010111000111111000110011000001011101011011010000100011111100010000010100010011011011111011010010110010110101111011101100111000101110001100100100100000101110000110011111011010110000110001010110111101001010111101101100001001011000111011100010111000000100001001101000011110110110100111000111011001101010001101000111110111000110000101111001110001010000101011100111110001101101100111011111111010110011011011100011010110000000000010111000011000011110000010011000001001011100000110010100001011110100100101000110001011100110111010100000100010011001001001110010110111010000111101111001111010001110111100001101011011001111100001100110101000000011010101110001100110111111000001001100110011101000110101101100100001110011101011110011010101110001110101001111011100100010010000010001001001100001011110100010010101111001110101111010010000001010101110111011111100001110011110"
answer2 = "1010111000110101001100001000011110000100101010001110100010011111110000111111001000001111101101010111111000101100001101001101101011011111100101101000111000000111001100111110100010100100101111011100000011101111101011101100100100000100101101001101001010000100010011000111010001110011011011011111010001111001100000100101001111001110101001000010110101000010010011110110100111000100011101000111111011110110010111100001001001011000111000100110010101110010111000001000111001111010000110001110101111010100011000001110010010011000100000000101001100100100011100101001111111111101000111100111100001111101100111110110100011111001101011110100001011011010111001110100011001000101011111011101100110110110001101001000101111000010000110000101110001000011110010100100110000011110011001010111111100101010001110011001000000111110110011001100010111001010010011011110001100010100001100101010001110001010110000100011011101101111101110110110011110100001011101101010000110001010000101101111110101010001000100000011110001100001"
# all 100%

# data 3, easy low error
# answer1 = "1011100111111101110100001000100101011011111011010111110000000100101000101100000110000001001101010010"
# answer2 = "0100011000000010001011110111011010100100000100101000001111111011010111010011111001111110110010101101"
# all 100%

# data 3, medium low error
# answer1 = "110000001110000010100111111011111001000100010111110010010100110011001100101010001100110000000111111101011101000011100110011010011100111000100111010011001001101011001101001110100110110101011000100100110110001000000100001101111110111101001011111110101010100001011001011111000110100111111010011111100100011010010011010000010001110111111110000010010001100010101001111111111101101001100101011100001111110001111101010000011111011111000000000000101100110001100111111101111100000111110101100101011010011111000101010000000100011001110111010100101000110011111010001001000011"
# answer2 = "001111110001111101011000000100000110111011101000001101101011001100110011010101110011001111111000000010100010111100011001100101100011000111011000101100110110010100110010110001011001001010100111011011001001110111111011110010000001000010110100000001010101011110100110100000111001011000000101100000011011100101101100101111101110001000000001111101101110011101010110000000000010010110011010100011110000001110000010101111100000100000111111111111010011001110011000000010000011111000001010011010100101100000111010101111111011100110001000101011010111001100000101110110111100"
# all 100%

# Final_2, high error data - currently 54.7% and 51.7%
# answer1 = "0100101000011100011000010000101101010000111111011101111110000100001000000011001100100001001001010111011110001100101001100111101100001010101000000100011101101101010010011011111100000101000101111111010011101010001000001110100011110111000111111110111111001101000110111101011011111100101101101011011100110110110111101011110110101010101111011011000100010010100101111100000111011010010001111101010000011101100101101010001110011101101001100000100010000000011100011011000000011000010111001110111001000000110100111111111110011001000010010011001110111011000000110000110111010001110110001000011101101110001111110010111011001100110001110000111110000111110010000100101110011001110111110010101100011001111101000110110100010111001010111011011101011000011110111111111101001100100011011100101010001001000100001011001110111000101001000100000110100100100110000000101100110001011011010100000000110110111001100100111011010110110100001100010010111110100011011111101001100000101010110100010010000011001110111010101101101001"
# answer2 = "1011010111100011100111101111010010101111000000100010000001111011110111111100110011011110110110101000100001110011010110011000010011110101010111111011100010010010101101100100000011111010111010000000101100010101110111110001011100001000111000000001000000110010111001000010100100000011010010010100100011001001001000010100001001010101010000100100111011101101011010000011111000100101101110000010101111100010011010010101110001100010010110011111011101111111100011100100111111100111101000110001000110111111001011000000000001100110111101101100110001000100111111001111001000101110001001110111100010010001110000001101000100110011001110001111000001111000001101111011010001100110001000001101010011100110000010111001001011101000110101000100100010100111100001000000000010110011011100100011010101110110111011110100110001000111010110111011111001011011011001111111010011001110100100101011111111001001000110011011000100101001001011110011101101000001011100100000010110011111010101001011101101111100110001000101010010010110"

# medium, high error data -
# answer3 = "01001010000111000110000100001011010100001111110111011111100001000010000000110011001000010010010101110111100011001010011001111011000010101010000001000111011011010100100110111111000001010001011111110100111010100010000011101000111101110001111111101111110011010001101111010110111111001011011010110111001101101101111010111101101010101011110110110001000100101001011111000001110110100100011111010100000111011001011010100011100111011010011000001000100000000111000110110000000110000101110011101110010000001101001111111111100110010000100100110011101110110000001100001101110"
# answer4 = "10110101111000111001111011110100101011110000001000100000011110111101111111001100110111101101101010001000011100110101100110000100111101010101111110111000100100101011011001000000111110101110100000001011000101011101111100010111000010001110000000010000001100101110010000101001000000110100100101001000110010010010000101000010010101010100001001001110111011010110100000111110001001011011100000101011111000100110100101011100011000100101100111110111011111111000111001001111111001111010001100010001101111110010110000000000011001101111011011001100010001001111110011110010001"

# data 3, easy high error - currently 100%
# answer5 = "0101111100111101101111010010001000000001100101111100101011000111000000000100010110011101111000100001"
# answer6 = "1010000011000010010000101101110111111110011010000011010100111000111111111011101001100010000111011110"

# print the percentage similarity between assembled haplotypes and actual haplotypes
print percentOverlap(hap1, answer1)
print percentOverlap(hap2, answer2)